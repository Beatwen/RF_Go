@using MudBlazor
@using Newtonsoft.Json
@using System.IO
@using System
@using RF_Go.Data
@using RF_Go.Models
@using RF_Go.ViewModels
@using System.Diagnostics

@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

        @if (DevicesViewModel.Devices.Count == 0)
        {
            <MudAlert Severity="Severity.Info" Variant="Variant.Filled">No devices found</MudAlert>
        }
        else
        {
    <MudTable class="" Hover="true" Dense="true" Bordered="false" Striped="false" HorizontalScrollbar="true" @bind-Items="DevicesViewModel.Devices" @ref="mudTable"
              RowClass="cursor-pointer" RowClassFunc="@SelectedRowClassFunc">
        <ToolBarContent>

            <div class="d-flex align-center justify-start">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="btn btn-primary" @onclick="RFCalcul">Calculate</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Secondary" Class="btn btn-primary" @onclick="DeleteAll">Delete All Devices</MudButton>
            </div>

            <MudText Typo="Typo.h6">Devices</MudText>

            <MudSpacer />
            <MudTextField @bind-Value="searchString1" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>Device</MudTh>
            <MudTh>Set Frequencies</MudTh>
            <MudTh>Inclusion Group</MudTh>
        </HeaderContent>
        <RowTemplate>
                <MudTd>
                    <div class="d-flex flex-column">
                        <p>@context.Brand - @context.Model</p>
                        
                        <p>@context.ID - @context.Name</p>
                        <p>@context.Frequency - @GetFrequencyDetails(context)</p>
                        <p>@(context.IpAddress != null ? context.IpAddress : "No ip-address")</p>
                    </div>
                </MudTd>
                @* <MudTd>@SetGetNumberOfChannels(context)</MudTd> *@
                <MudTd Style="min-width:250px">
                    <MudTable @bind-Items="@context.Channels" Hover="true">
                        <RowTemplate Context="chan">

                            @*  <MudTd>@string.Format("{0:#,0}", chan.Frequency) </MudTd> *@

                        <MudTd Class="d-flex align-center mt-0">
                            <MudNumericField @bind-Value="chan.Frequency" Min="@chan.Range[0]" Max="@chan.Range[1]" Step="@chan.Step" Style="@CalculateStyle(chan)" Class="mt-0" Label="Frequency" Variant="Variant.Outlined" />
                                <MudCheckBox Color="Color.Secondary" CheckedIcon="@Icons.Material.Filled.Favorite" UncheckedIcon="@Icons.Material.Filled.FavoriteBorder" Value="@chan.IsLocked"></MudCheckBox>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudTd>
                <MudTd>
                    <MudSelect T="int" Value="context.GroupID" ValueChanged="(newGroupId) => GroupsViewModel.UpdateDeviceGroupAsync(context, newGroupId)">
                        @foreach (var group in GroupsViewModel.Groups)
                        {
                            <MudSelectItem Value="@group.ID">@group.Name</MudSelectItem>
                        }
                    </MudSelect>
                    <div class="d-flex">
                        <MudButton Color=Color.Primary class="edit-button">Edit</MudButton>
                        <MudButton Color=Color.Secondary class="delete-button" @onclick="() => DevicesViewModel.DeleteDeviceAsync(context.ID)">Del</MudButton>
                    </div>
                </MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager />
            </PagerContent>
        </MudTable>
        }

    @code 
    {
        [Parameter] public DevicesViewModel DevicesViewModel { get; set; }
        [Parameter] public GroupsViewModel GroupsViewModel { get; set; }
        [Parameter] public DeviceData DeviceData { get; set; }
        [Parameter] public EventCallback OnDeviceSaved { get; set; }

        private RFDevice Device => DevicesViewModel.OperatingDevice;
        private string searchString1 = "";
        private MudTable<RFDevice> mudTable;
        private int selectedRowNumber = -1;
        private bool selectAll { get; set; }
        private List<string> clickedEvents = new();
    

        private string CalculateStyle(RFChannel chan)
        {
            string color = chan.Checked ? "lightgreen" : "red";
        return "color:" + color + "; align-self: center; ";
        }
        private string SelectedRowClassFunc(RFDevice device, int rowNumber)
        {
            if (selectedRowNumber == rowNumber)
            {
                selectedRowNumber = -1;
                clickedEvents.Add("Selected Row: None");
                return string.Empty;
            }
            else if (mudTable.SelectedItem != null && mudTable.SelectedItem.Equals(device))
            {
                selectedRowNumber = rowNumber;
                clickedEvents.Add($"Selected Row: {rowNumber}");
                return "selected";
            }
            else
            {
                return string.Empty;
            }
        }
        private string GetFrequencyDetails(RFDevice context)
        {
            int startRange = DeviceData.Brands[context.Brand][context.Model][context.Frequency][0];
            int endRange = DeviceData.Brands[context.Brand][context.Model][context.Frequency][1];
            return $"{startRange:#,0} - {endRange:#,0}";
        }
        protected override async Task OnInitializedAsync()
        {
            await DevicesViewModel.LoadDevicesAsync();
            await GroupsViewModel.LoadGroupsAsync();
            await base.OnInitializedAsync();
        }        private bool isAddingDevice = false;
        private int selectedQuantity = 1;
        private List<int> frequencyOptions = Enumerable.Range(1, 99).ToList();
        private async Task SaveDeviceInDB(RFDevice device)
        {
            SaveDataDevicesInfo(device);
            SaveDataChannelsInfo(device);

            for (int i = 0; i < selectedQuantity; i++)
            {
                await DevicesViewModel.SaveDeviceAsync();
            }

            await DevicesViewModel.LoadDevicesAsync();
            StateHasChanged();
        }
        private void DeleteDevice(RFDevice context)
        {
            DevicesViewModel.SetOperatingDevice(context);
        }

        private void SaveDataDevicesInfo(RFDevice device)
        {
            Debug.WriteLine("SaveDataDevice is called");
            device.Range = DeviceData.Brands[device.Brand][device.Model][device.Frequency];
            device.Step = (int)DeviceData.Brands[device.Brand][device.Model][device.Frequency][3];
            device.NumberOfChannels = (int)DeviceData.Brands[device.Brand][device.Model][device.Frequency][2];
            Debug.WriteLine(device.NumberOfChannels);
            device.Channels = new List<RFChannel>();
            for (int i = 0; i < device.NumberOfChannels; i++)
            {
                device.Channels.Add(new RFChannel());
                Debug.WriteLine("Channel created");
            }
        }
        private void SaveDataChannelsInfo(RFDevice device)
        {
            var freq = DeviceData.Brands[device.Brand][device.Model][device.Frequency];
            int count = 1;
            foreach (RFChannel chan in device.Channels)
            {
                chan.Range = device.Range;
                chan.Step = device.Step;
                chan.chanNumber = count;
                chan.SelfSpacing = freq[4];
                chan.ThirdOrderSpacing = freq[5];
                chan.FifthOrderSpacing = freq[6];
                chan.SeventhOrderSpacing = freq[7];
                chan.ThirdOrderSpacing3Tx = freq[8];
                count++;
            }
        }
        private void AddDevice()
        {
            isAddingDevice = true;
        }
    private async Task RFCalcul()
    {
        var overlappingGroups = FindOverlappingGroups();
        foreach (var groupSet in overlappingGroups)
        {
            HashSet<int> UsedFrequencies = new HashSet<int>();
            HashSet<int> TwoTX3rdOrder = new HashSet<int>();
            HashSet<int> TwoTX5rdOrder = new HashSet<int>();
            HashSet<int> TwoTX7rdOrder = new HashSet<int>();
            HashSet<int> TwoTX9rdOrder = new HashSet<int>();
            HashSet<int> ThreeTX3rdOrder = new HashSet<int>();

            var devicesInGroup = GetDevicesForGroupSet(groupSet);

            // First pass: lock frequencies
            foreach (RFDevice device in devicesInGroup)
            {
                foreach (RFChannel chan in device.Channels)
                {
                    chan.Checked = false;
                    if (chan.IsLocked)
                    {
                        Debug.WriteLine("We are checking: " + chan.Frequency);
                        chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder);
                    }
                }
            }

            // Second pass: assign frequencies to unlocked channels
            foreach (RFDevice device in devicesInGroup)
            {
                foreach (RFChannel chan in device.Channels)
                {
                    chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder);
                }
            }
            await OnDeviceSaved.InvokeAsync();
        }
    }
    private List<RFDevice> GetDevicesForGroupSet(List<RFGroup> groupSet)
    {
        var groupIds = groupSet.Select(g => g.ID).ToList();
        return DevicesViewModel.Devices.Where(device => groupIds.Contains(device.GroupID)).ToList();
    }
    private List<List<RFGroup>> FindOverlappingGroups()
    {
        var processedGroups = new HashSet<RFGroup>();
        var overlappingGroups = new List<List<RFGroup>>();

        foreach (var group in GroupsViewModel.Groups)
        {
            if (processedGroups.Contains(group))
                continue;

            var overlappingSet = new List<RFGroup> { group };
            processedGroups.Add(group);

            foreach (var otherGroup in GroupsViewModel.Groups)
            {
                if (group == otherGroup || processedGroups.Contains(otherGroup))
                    continue;

                if (DoGroupsOverlap(group, otherGroup))
                {
                    overlappingSet.Add(otherGroup);
                    processedGroups.Add(otherGroup);
                }
            }
            overlappingGroups.Add(overlappingSet);
        }

        return overlappingGroups;
    }

    private bool DoGroupsOverlap(RFGroup group1, RFGroup group2)
    {
        foreach (var period1 in group1.TimePeriods)
        {
            foreach (var period2 in group2.TimePeriods)
            {
                if (DoPeriodsOverlap(period1, period2))
                {
                    return true;
                }
            }
        }
        return false;
    }

    private bool DoPeriodsOverlap(TimePeriod period1, TimePeriod period2)
    {
        var answer = period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
        return period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
    }

    private async Task DeleteAll()
    {
        await DevicesViewModel.DeleteAllDeviceAsync();
        await OnDeviceSaved.InvokeAsync();
    }
    }