@using MudBlazor
@using Newtonsoft.Json
@using System.IO
@using System
@using RF_Go.Data
@using RF_Go.Models
@using RF_Go.ViewModels
@using System.Diagnostics
@inject MudBlazor.ISnackbar Snackbar

@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

        @if (DevicesViewModel.Devices.Count == 0)
        {
            <MudAlert Severity="Severity.Info" Variant="Variant.Filled">No devices found</MudAlert>
        }
        else
        {
    <div class="d-flex pl-6 pr-6 w-100 align-center justify-space-between pt-2">
        <div class="flex-none d-flex">
            <MudText Typo="Typo.h5" Class="">Devices</MudText>
        </div>
        <div class="">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mx-2" @onclick="RFCalcul">
                Calculate
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mx-2" @onclick="RFCalcul">
                Send Data to Device
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" Class="mx-2" @onclick="DeleteAll">
                Delete All Devices
            </MudButton>
        </div>
    </div>
    
    <MudTable Height="70vh" Hover="true" Dense="true" Bordered="false" Striped="false" HorizontalScrollbar="true" @bind-Items="DevicesViewModel.Devices" @ref="mudTable"
              RowClass="cursor-pointer" RowClassFunc="@SelectedRowClassFunc">
        <ToolBarContent>
            <MudSpacer />
            <MudTextField @bind-Value="searchString1" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
        </ToolBarContent>
        <HeaderContent>
            <MudTh Style="min-width: 200px;">Device</MudTh>
            <MudTh Style="min-width: 150px;">Set Frequencies</MudTh>
            <MudTh Style="min-width: 150px;">Inclusion Group</MudTh>
        </HeaderContent>

        <RowTemplate>
                <MudTd>
@*                  <div class="d-flex flex-column">
                     <MudTextField Typo="Typo.caption" Style="padding:0;" Label="@GetBrandAndModel(context)" @bind-Value="@context.Name"
                                   @onblur="() => SaveDeviceAsync(context)" HelperText="@GetFrequency(context)" />
                     <MudTextField Typo="Typo.caption" Style="margin:0;" @bind-Value="@context.IpAddress" HelperText="Ip Address" Placeholder="IP Address" @onblur="() => SaveDeviceAsync(context)" Class="custom-textfield" />
                 </div> *@
                    <MudTable @bind-Items="@context.Channels" Hover="true">
                        <RowTemplate Context="chan">
                            <MudTd Class="d-flex align-center mt-0">
                            <MudTextField Typo="Typo.caption" Label="@GetBrandAndModel(context)" @bind-Value="@chan.ChannelName" Class="mt-0" Margin="Margin.Dense" Variant="Variant.Outlined"
                                              @onblur="() => SaveDeviceAsync(context)" />
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudTd>
                <MudTd>
                <MudTable @bind-Items="@context.Channels" Hover="true" Style="width:190px;">
                        <RowTemplate Context="chan" >
                            @*  <MudTd>@string.Format("{0:#,0}", chan.Frequency) </MudTd> *@

                            <MudTd Class="d-flex align-center mt-0">
                                <MudNumericField @bind-Value="chan.Frequency" Min="@chan.Range[0]" Max="@chan.Range[1]" Step="@chan.Step" Style="@CalculateStyle(chan)" Class="mt-0" Label="@GetRange(chan)" Variant="Variant.Outlined" Margin="Margin.Dense" />
                                <MudCheckBox @bind-Value="chan.IsLocked" Color="Color.Secondary" CheckedIcon="@Icons.Material.Filled.Favorite" UncheckedIcon="@Icons.Material.Filled.FavoriteBorder" Class="pl-1"></MudCheckBox>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudTd>
                <MudTd>
                    <div class="d-flex justify-content-between">
                        <MudSelect T="int" Value="context.GroupID" ValueChanged="(newGroupId) => GroupsViewModel.UpdateDeviceGroupAsync(context, newGroupId)">
                            @foreach (var group in GroupsViewModel.Groups)
                            {
                                <MudSelectItem Value="@group.ID">@group.Name</MudSelectItem>
                            }
                        </MudSelect>
                        <MudIconButton Icon="@Icons.Material.Filled.Delete" @onclick="() => DeleteDevice(context)" aria-label="delete" />
                </div>
                <MudTextField Typo="Typo.caption" Style="margin:0;" @bind-Value="@context.IpAddress" Placeholder="IP Address" @onblur="() => SaveDeviceAsync(context)" Class="custom-textfield" />
            </MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager />
            </PagerContent>
        </MudTable>
        }

    @code 
{
    [Parameter] public DevicesViewModel DevicesViewModel { get; set; }
    [Parameter] public GroupsViewModel GroupsViewModel { get; set; }
    [Parameter] public DeviceData DeviceData { get; set; }
    [Parameter] public ExclusionChannelViewModel ExclusionChannelViewModel { get; set; }
    [Parameter] public EventCallback OnDeviceSaved { get; set; }

    private RFDevice Device => DevicesViewModel.OperatingDevice;
    private string searchString1 = "";
    private MudTable<RFDevice> mudTable;
    private int selectedRowNumber = -1;
    private bool selectAll { get; set; }
    private List<string> clickedEvents = new();



    private string CalculateStyle(RFChannel chan)
    {
        string color = chan.Checked ? "lightgreen" : "red";
        return "color:" + color + "; align-self: center; ";
    }
    private string SelectedRowClassFunc(RFDevice device, int rowNumber)
    {
        if (selectedRowNumber == rowNumber)
        {
            selectedRowNumber = -1;
            clickedEvents.Add("Selected Row: None");
            return string.Empty;
        }
        else if (mudTable.SelectedItem != null && mudTable.SelectedItem.Equals(device))
        {
            selectedRowNumber = rowNumber;
            clickedEvents.Add($"Selected Row: {rowNumber}");
            return "selected";
        }
        else
        {
            return string.Empty;
        }
    }
    private string GetBrandAndModel(RFDevice device)
    {
        return device.Brand + "-" + device.Model;
    }
    private string GetFrequency(RFDevice device)
    {
        int startRange = DeviceData.Brands[device.Brand][device.Model][device.Frequency][0];
        int endRange = DeviceData.Brands[device.Brand][device.Model][device.Frequency][1];
        return device.Frequency + " - " + $"{startRange:#,0} - {endRange:#,0}";
    }

    protected override async Task OnInitializedAsync()
    {
        await DevicesViewModel.LoadDevicesAsync();
        await GroupsViewModel.LoadGroupsAsync();
        await base.OnInitializedAsync();
    }        private bool isAddingDevice = false;
    private int selectedQuantity = 1;
    private List<int> frequencyOptions = Enumerable.Range(1, 99).ToList();
    private async Task DeleteDevice(RFDevice device)
    {
        await DevicesViewModel.DeleteDeviceAsync(device.ID);
        Snackbar.Add("Device deleted", Severity.Success);
    }
    private List<(int StartFrequency, int EndFrequency)> GetExcludedRanges()
    {
        return ExclusionChannelViewModel.ExclusionChannels
            .Where(channel => channel.Exclude)
            .Select(channel => (int.Parse(channel.StartFrequency), int.Parse(channel.EndFrequency)))
            .ToList();
    }
    private async Task RFCalcul()
    {
        var overlappingGroups = FindOverlappingGroups();
        var excludedRanges = GetExcludedRanges();

        foreach (var groupSet in overlappingGroups)
        {
            HashSet
    <int> UsedFrequencies = new HashSet<int>();
            HashSet<int> TwoTX3rdOrder = new HashSet<int>();
            HashSet<int> TwoTX5rdOrder = new HashSet<int>();
            HashSet<int> TwoTX7rdOrder = new HashSet<int>();
            HashSet<int> TwoTX9rdOrder = new HashSet<int>();
            HashSet<int> ThreeTX3rdOrder = new HashSet<int>();

            var devicesInGroup = GetDevicesForGroupSet(groupSet);

            // First pass: lock frequencies
            foreach (RFDevice device in devicesInGroup)
            {
                foreach (RFChannel chan in device.Channels)
                {
                    chan.Checked = false;
                    if (chan.IsLocked)
                    {
                        Debug.WriteLine("found one locked chan ! ");
                        Debug.WriteLine("We are checking: " + chan.Frequency);
                        chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder, excludedRanges);
                    }
                }
            }

            // Second pass: assign frequencies to unlocked channels
            foreach (RFDevice device in devicesInGroup)
            {
                foreach (RFChannel chan in device.Channels)
                {
                    chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder, excludedRanges);
                }
            }
            await OnDeviceSaved.InvokeAsync();
        }
    }
    private List<RFDevice> GetDevicesForGroupSet(List<RFGroup> groupSet)
    {
        var groupIds = groupSet.Select(g => g.ID).ToList();
        return DevicesViewModel.Devices.Where(device => groupIds.Contains(device.GroupID)).ToList();
    }
    private List<List<RFGroup>> FindOverlappingGroups()
    {
        var processedGroups = new HashSet<RFGroup>();
        var overlappingGroups = new List<List<RFGroup>>();

        foreach (var group in GroupsViewModel.Groups)
        {
            if (processedGroups.Contains(group))
                continue;

            var overlappingSet = new List<RFGroup> { group };
            processedGroups.Add(group);

            foreach (var otherGroup in GroupsViewModel.Groups)
            {
                if (group == otherGroup || processedGroups.Contains(otherGroup))
                    continue;

                if (DoGroupsOverlap(group, otherGroup))
                {
                    overlappingSet.Add(otherGroup);
                    processedGroups.Add(otherGroup);
                }
            }
            overlappingGroups.Add(overlappingSet);
        }

        return overlappingGroups;
    }
    private bool DoGroupsOverlap(RFGroup group1, RFGroup group2)
    {
        foreach (var period1 in group1.TimePeriods)
        {
            foreach (var period2 in group2.TimePeriods)
            {
                if (DoPeriodsOverlap(period1, period2))
                {
                    return true;
                }
            }
        }
        return false;
    }
    private bool DoPeriodsOverlap(TimePeriod period1, TimePeriod period2)
    {
        var answer = period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
        return period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
    }
    private async Task SaveDeviceAsync(RFDevice device)
    {
        DevicesViewModel.SetOperatingDevice(device);
        await DevicesViewModel.SaveDeviceAsync();
    }
    private async Task DeleteAll()
    {
        await DevicesViewModel.DeleteAllDeviceAsync();
        // forcing the refresh of the UI 
        await OnDeviceSaved.InvokeAsync();
    }
    private string GetRange(RFChannel chan)
    {
        string startRange = (chan.Range[0] / 1000).ToString();
        string endRange = (chan.Range[1] / 1000).ToString();
        return $"{startRange} - {endRange} Mhz";
    }
}