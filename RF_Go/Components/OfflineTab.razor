@using Newtonsoft.Json
@using System.IO
@using System
@using RF_Go.Data
@using RF_Go.Models
@using RF_Go.Components.Modal
@using RF_Go.ViewModels
@using System.Diagnostics
@using System.ComponentModel;

@inject IDialogService Dialog
@inject MudBlazor.ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

@if (DevicesViewModel.Devices.Count == 0)
{
    <MudContainer MaxWidth="MaxWidth.Medium" Style="display: flex; justify-content: center; align-items: center;">
        <MudPaper Class="pa-6" Elevation="3" Style="text-align: center; max-width: 400px;">
            <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="mb-4">
                No devices found. Start by adding a device.
            </MudAlert>
            <MudFab Color="Color.Success" StartIcon="@Icons.Material.Filled.Add" OnClick="@(() => OpenDialogToAddDeviceAsync())">
                Add Device
            </MudFab>
        </MudPaper>
    </MudContainer>
}
else
{
    <div class="d-flex pl-6 pr-6 w-100 align-center justify-space-between pt-2">
        <MudFab Color="Color.Primary" Size="Size.Small" StartIcon="@Icons.Material.Filled.Add" OnClick="@(() => OpenDialogToAddDeviceAsync())">Open</MudFab>
        <div>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mx-2" @onclick="RFCalcul">
                Calculate
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mx-2" @onclick="OpenDialogOnlineDevice">
                Sync
            </MudButton>
        </div>
    </div>

    <MudTable Hover="true" Dense="true" Bordered="false" Striped="false" HorizontalScrollbar="true" @bind-Items="DevicesViewModel.Devices" @ref="mudTable"
    RowClass="cursor-pointer" RowClassFunc="@SelectedRowClassFunc" Style="margin: auto; overflow: auto; max-height: calc(100vh - 150px);">
        <HeaderContent>
            <MudTh Style="min-width: 200px;">Device</MudTh>
            <MudTh Style="min-width: 150px;">Set Frequencies</MudTh>
            <MudTh Class="d-flex align-center justify-space-between" Style="min-width: 150px;">
                <span>Group</span>
                <MudIconButton Icon="@Icons.Material.Filled.Delete" @onclick="DeleteAll" />
            </MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd>
                <MudTable @bind-Items="@context.Channels" Hover="true" Style="min-width:70px;">
                    <RowTemplate Context="chan">
                        <MudTd Class="d-flex align-center mt-0">
                            <MudTextField Typo="Typo.caption" Label="@GetBrandAndModel(context)" @bind-Value="@chan.ChannelName" Class="mt-0" Margin="Margin.Dense" Variant="Variant.Outlined"
                            @onblur="() => SaveDeviceAsync(context)" />
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTd>
            <MudTd>
                <MudTable @bind-Items="@context.Channels" Hover="true" Style="min-width:70px;">
                    <RowTemplate Context="chan">
                        <MudTd Class="d-flex align-center mt-0">
                            <MudNumericField @bind-Value="chan.Frequency" Min="@chan.Range[0]" Max="@chan.Range[1]" Step="@chan.Step" Style="@CalculateStyle(chan)" Class="mt-0" Label="@GetRange(chan)" Variant="Variant.Outlined" Margin="Margin.Dense" @onblur="() => SaveDeviceAsync(context)" />
                            <MudCheckBox @bind-Value="chan.IsLocked" Dense="true" Color="Color.Secondary" CheckedIcon="@Icons.Material.Filled.Lock" UncheckedIcon="@Icons.Material.Filled.LockOpen" Class="pl-3"></MudCheckBox>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            </MudTd>
            <MudTd>
                <div class="d-flex justify-content-between">
                    <MudSelect T="int" Value="context.GroupID" ValueChanged="(newGroupId) => GroupsViewModel.UpdateDeviceGroupAsync(context, newGroupId)">
                        @foreach (var group in GroupsViewModel.Groups)
                        {
                            <MudSelectItem Value="@group.ID">@group.Name</MudSelectItem>
                        }
                    </MudSelect>
                    @if (context.IsSynced)
                    {
                        <MudIconButton Icon="@Icons.Material.Filled.LinkOff" @onclick="() => DesyncDevice(context)" aria-label="desync" />
                    }
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" @onclick="() => DeleteDevice(context)" aria-label="delete" />
                </div>
                <div class="d-flex justify-content-between">
                    <MudTextField Typo="Typo.caption" Style="margin:0;" @bind-Value="@context.IpAddress" Placeholder="IP Address" @onblur="() => SaveDeviceAsync(context)" Class="custom-textfield" />
                    <MudIconButton @onclick="() => OpenQuickSyncModal(context)" Icon="@GetSyncIcon(context)" Color="@GetSyncColor(context)" Size="Size.Small" />
                </div>
            </MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}

@code
{
    [Parameter] public DevicesViewModel DevicesViewModel { get; set; }
    [Parameter] public GroupsViewModel GroupsViewModel { get; set; }
    [Parameter] public DeviceData DeviceData { get; set; }
    [Parameter] public ExclusionChannelViewModel ExclusionChannelViewModel { get; set; }
    [Parameter] public EventCallback OnDeviceSaved { get; set; }

    private RFDevice Device => DevicesViewModel.OperatingDevice;
    private string searchString1 = "";
    private MudTable<RFDevice> mudTable;
    private int selectedRowNumber = -1;
    private bool selectAll { get; set; }
    private List<string> clickedEvents = new();
    private bool OfflineBoxVisibility = false;
    private bool isAddingDevice = false;
    private int selectedQuantity = 1;
    private List<int> frequencyOptions = Enumerable.Range(1, 99).ToList();

    private string CalculateStyle(RFChannel chan)
    {
        string color = chan.Checked ? "lightgreen" : "red";
        return "color:" + color + "; align-self: center; ";
    }
    private string IsChanLocked(RFChannel chan, bool e)
    {
        chan.IsLocked = e;
        return e.ToString();
    }
    private string SelectedRowClassFunc(RFDevice device, int rowNumber)
    {
        if (selectedRowNumber == rowNumber)
        {
            selectedRowNumber = -1;
            clickedEvents.Add("Selected Row: None");
            return string.Empty;
        }
        else if (mudTable.SelectedItem != null && mudTable.SelectedItem.Equals(device))
        {
            selectedRowNumber = rowNumber;
            clickedEvents.Add($"Selected Row: {rowNumber}");
            return "selected";
        }
        else
        {
            return string.Empty;
        }
    }
    private string GetBrandAndModel(RFDevice device)
    {
        return device.Brand + "-" + device.Model;
    }
    private string GetFrequency(RFDevice device)
    {
        int startRange = DeviceData.Brands[device.Brand][device.Model][device.Frequency][0];
        int endRange = DeviceData.Brands[device.Brand][device.Model][device.Frequency][1];
        return device.Frequency + " - " + $"{startRange:#,0} - {endRange:#,0}";
    }
    @code {
        protected override async Task OnInitializedAsync()
        {
            try
            {
                if (DevicesViewModel == null)
                {
                    throw new InvalidOperationException("DevicesViewModel is not initialized.");
                }
                if (GroupsViewModel == null)
                {
                    throw new InvalidOperationException("GroupsViewModel is not initialized.");
                }
                if (DeviceData == null)
                {
                    throw new InvalidOperationException("DeviceData is not initialized.");
                }
                if (ExclusionChannelViewModel == null)
                {
                    throw new InvalidOperationException("ExclusionChannelViewModel is not initialized.");
                }

                await DevicesViewModel.LoadDevicesAsync();
                await GroupsViewModel.LoadGroupsAsync();

                foreach (var device in DevicesViewModel.Devices)
                {
                    device.PropertyChanged += Device_PropertyChanged;
                }

                await base.OnInitializedAsync();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in OnInitializedAsync: {ex.Message}");
                throw;
            }
        }

        private void Device_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(RFDevice.IsSynced) || e.PropertyName == nameof(RFDevice.PendingSync))
            {
                InvokeAsync(StateHasChanged);
            }
        }

        public void Dispose()
        {
            foreach (var device in DevicesViewModel.Devices)
            {
                device.PropertyChanged -= Device_PropertyChanged;
            }
        }
    }


    private async Task DeleteDevice(RFDevice device)
    {
    await DevicesViewModel.DeleteDeviceAsync(device.ID);
    Snackbar.Add("Device deleted", Severity.Success);
    }
    private async Task DesyncDevice(RFDevice device)
    {
    device.IsSynced = false;
    device.PendingSync = false;
    device.SerialNumber = null;
    device.IpAddress = null;

    // Rechercher l'objet correspondant dans la collection OnlineDevices
    var matchingDevice = DevicesViewModel.OnlineDevices.FirstOrDefault(d => d.ID == device.ID);
    if (matchingDevice != null)
    {
        Debug.WriteLine($"Device {device.Name} found in OnlineDevices before removal.");
        DevicesViewModel.OnlineDevices.Remove(matchingDevice);
        Debug.WriteLine($"Device {device.Name} successfully removed from OnlineDevices.");
    }
    else
    {
        Debug.WriteLine($"Device {device.Name} not found in OnlineDevices before removal.");
    }

    await SaveDeviceAsync(device);
    Snackbar.Add("Device desynchronized", Severity.Info);
    }
    private List<(float StartFrequency, float EndFrequency)> GetExcludedRanges()
    {
    var excludedChannels = ExclusionChannelViewModel.ExclusionChannels
        .Where(channel => channel.Exclude)
        .Concat(ExclusionChannelViewModel.UserAddedChannels.Where(channel => channel.Exclude))
        .Select(channel => (channel.StartFrequency, channel.EndFrequency))
        .ToList();

    return excludedChannels;
    }
    private async Task RFCalcul()
    {
    var overlappingGroups = FindOverlappingGroups();
    var excludedRanges = GetExcludedRanges();

    foreach (var groupSet in overlappingGroups)
    {
        HashSet<int> UsedFrequencies = new HashSet<int>();
        HashSet<int> TwoTX3rdOrder = new HashSet<int>();
        HashSet<int> TwoTX5rdOrder = new HashSet<int>();
        HashSet<int> TwoTX7rdOrder = new HashSet<int>();
        HashSet<int> TwoTX9rdOrder = new HashSet<int>();
        HashSet<int> ThreeTX3rdOrder = new HashSet<int>();

        var devicesInGroup = GetDevicesForGroupSet(groupSet);

        // First pass: lock frequencies
        foreach (RFDevice device in devicesInGroup)
        {
            foreach (RFChannel chan in device.Channels)
            {
                chan.Checked = false;
                if (chan.IsLocked)
                {
                    Debug.WriteLine("found one locked chan ! ");
                    Debug.WriteLine("We are checking: " + chan.Frequency);
                    chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder, excludedRanges);
                }
            }
        }

        // Second pass: assign frequencies to unlocked channels
        foreach (RFDevice device in devicesInGroup)
        {
            foreach (RFChannel chan in device.Channels)
            {
                chan.SetRandomFrequency(UsedFrequencies, TwoTX3rdOrder, TwoTX5rdOrder, TwoTX7rdOrder, TwoTX9rdOrder, ThreeTX3rdOrder, excludedRanges);
            }
        }
        await DevicesViewModel.SaveAllDevicesAsync();
        await OnDeviceSaved.InvokeAsync();
        }
    }
    private List<RFDevice> GetDevicesForGroupSet(List<RFGroup> groupSet)
    {
        var groupIds = groupSet.Select(g => g.ID).ToList();
        return DevicesViewModel.Devices.Where(device => groupIds.Contains(device.GroupID)).ToList();
    }
    private List<List<RFGroup>> FindOverlappingGroups()
    {
        var processedGroups = new HashSet<RFGroup>();
        var overlappingGroups = new List<List<RFGroup>>();

        foreach (var group in GroupsViewModel.Groups)
        {
            if (processedGroups.Contains(group))
                continue;

            var overlappingSet = new List<RFGroup> { group };
            processedGroups.Add(group);

            foreach (var otherGroup in GroupsViewModel.Groups)
            {
                if (group == otherGroup || processedGroups.Contains(otherGroup))
                    continue;

                if (DoGroupsOverlap(group, otherGroup))
                {
                    overlappingSet.Add(otherGroup);
                    processedGroups.Add(otherGroup);
                }
            }
            overlappingGroups.Add(overlappingSet);
        }

        return overlappingGroups;
    }
    private bool DoGroupsOverlap(RFGroup group1, RFGroup group2)
    {
        foreach (var period1 in group1.TimePeriods)
        {
            foreach (var period2 in group2.TimePeriods)
            {
                if (DoPeriodsOverlap(period1, period2))
                {
                    return true;
                }
            }
        }
        return false;
    }
    private bool DoPeriodsOverlap(TimePeriod period1, TimePeriod period2)
    {
        var answer = period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
        return period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime;
    }
    private async Task SaveDeviceAsync(RFDevice device)
    {
        DevicesViewModel.SetOperatingDevice(device);
        await DevicesViewModel.SaveDeviceAsync();
    }
    private async Task DeleteAll()
    {
        await DevicesViewModel.DeleteAllDeviceAsync();
        await OnDeviceSaved.InvokeAsync();
    }
    private string GetRange(RFChannel chan)
    {
        string startRange = (chan.Range[0] / 1000).ToString();
        string endRange = (chan.Range[1] / 1000).ToString();
        return $"{startRange} - {endRange} Mhz";
    }
    private readonly DialogOptions _maxWidth = new() { MaxWidth = MaxWidth.Medium, FullWidth = true };

    private async Task OpenDialogToAddDeviceAsync()
    {
        var parameters = new DialogParameters
        {
            { "DeviceData", DeviceData },
            { "DevicesViewModel", DevicesViewModel },
            { "GroupsViewModel", GroupsViewModel }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        var dialog = Dialog.Show<DeviceSelection>("Add your devices", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            StateHasChanged();
        }
    }

    private async Task OpenDialogOnlineDevice()
    {
        var parameters = new DialogParameters
        {
            { "DevicesViewModel", DevicesViewModel },
            //{ "OnDeviceSaved", EventCallback.Factory.Create(this, RefreshParentState) }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        var dialog = Dialog.Show<OnlineDevicesModal>("Online Devices", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            StateHasChanged();
        }
    }

    private async Task OpenQuickSyncModal(RFDevice device)
    {
        var parameters = new DialogParameters
        {
            { "Device", device },
            { "OnlineDevices", DevicesViewModel.OnlineDevices }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = Dialog.Show<SyncModal>("Quick Sync", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            StateHasChanged();
        }
    }
    private void RefreshParentState()
    {
        StateHasChanged();
    }
    private string GetSyncIcon(RFDevice device)
    {
        if (device.PendingSync)
        {
            return Icons.Material.Filled.Sync;
        }
        return device.IsSynced ? Icons.Material.Filled.CheckCircle : Icons.Material.Filled.Cancel;
    }
    private Color GetSyncColor(RFDevice device)
    {
        if (device.PendingSync)
        {
            return Color.Warning;
        }
        return device.IsSynced ? Color.Success : Color.Error;
    }
}


