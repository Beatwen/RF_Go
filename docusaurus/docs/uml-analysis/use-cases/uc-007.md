# UC-007: Gestion temporelle avancée

**Résumé :** Ce cas d'utilisation décrit la gestion temporelle avancée permettant la réutilisation intelligente des fréquences RF en fonction des créneaux horaires et des chevauchements temporels entre groupes d'équipements.

**Acteur :** Ingénieur Son/RF

**Précondition :**

- Des groupes avec périodes temporelles sont configurés
- Des équipements RF sont assignés aux groupes
- Au moins deux groupes avec des créneaux temporels différents existent

**Date de création :** 15 janvier 2025  
**Version :** 1.1

**Post condition :**

- Les fréquences sont optimisées selon les créneaux temporels
- La réutilisation fréquentielle est maximisée pour les groupes non-chevauchants
- L'occupation du spectre est optimisée dans le temps
- Les calculs d'intermodulation respectent les contraintes temporelles

## Acteurs secondaires

- **Système de calcul RF** : Module de calcul et d'optimisation des fréquences
- **Algorithme de détection** : Service de détection des chevauchements temporels

## Scénario nominal

| Acteur | Action |
|--------|--------|
| Ingénieur Son | Lance le calcul RF via RFCalcul() |
| Système | Démarre FrequencyCalculationService.CalculateFrequenciesAsync() |
| Système | Exécute `FindOverlappingGroups()` pour analyser les chevauchements |
| Système | Parcourt tous les groupes via _groupsViewModel.Groups |
| Système | Pour chaque groupe, vérifie s'il chevauche avec d'autres groupes |
| Système | Exécute `DoGroupsOverlap(group1, group2)` pour chaque paire |
| Système | Pour chaque paire de TimePeriod, applique `DoPeriodsOverlap()` |
| Système | Calcule: period1.StartTime < period2.EndTime && period1.EndTime > period2.StartTime |
| Système | Regroupe les groupes chevauchants dans overlappingGroups |
| Système | Traite chaque overlappingSet séparément pour l'optimisation |
| Système | Récupère les équipements via `GetDevicesForGroupSet(groupSet)` |
| Système | Applique le calcul RF en 3 passes pour chaque groupSet |
| Système | **Passe 1**: Traite les fréquences verrouillées (IsLocked) |
| Système | **Passe 2**: Calcule les fréquences libres pour les canaux non verrouillés |
| Système | **Passe 3**: Génère les fréquences de secours |
| Système | Stocke les données fréquentielles par groupe avec couleur distincte |
| Système | Sauvegarde les résultats via SaveAllDevicesAsync() et SaveFrequencyDataAsync() |

## Scénarios alternatifs

### Scénario alternatif 1: Groupes complètement disjoints

**Condition initiale** : Aucun chevauchement temporel détecté entre groupes
**Déclenchement** : `DoGroupsOverlap()` retourne false pour toutes les paires
**Actions** :

| Acteur | Action |
|--------|--------|
| Système | Détecte que chaque groupe forme son propre overlappingSet |
| Système | Optimise la réutilisation fréquentielle entre groupes disjoints |
| Système | Le calcul de ses fréquences sera fait totalement séparemment |

**Reprise** : Continuation du calcul RF normal

### Scénario alternatif 2: Chevauchement partiel complexe

**Condition initiale** : Plusieurs groupes avec chevauchements partiels
**Déclenchement** : Détection de patterns de chevauchement complexes
**Actions** :

| Acteur | Action |
|--------|--------|
| Système | Analyse les chevauchements multiples via FindOverlappingGroups() |
| Système | Identifie les clusters de groupes interconnectés |
| Système | Traite chaque cluster comme un ensemble cohérent |
| Système | Optimise les fréquences au niveau du cluster |
| Système | Applique des couleurs distinctes par cluster au niveau du SciChart |

**Reprise** : Retour au calcul RF pour les clusters identifiés

### Scénario alternatif 3: Contraintes temporelles insuffisantes

**Condition initiale** : Trop de groupes chevauchants pour l'optimisation
**Déclenchement** : Saturation du spectre disponible
**Actions** :

| Acteur | Action |
|--------|--------|
| Système | Détecte la saturation via le nombre d'overlappingGroups |
| Système | Priorise les groupes selon leur importance temporelle |
| Système | Applique un algorithme de fallback standard |
| Système | Génère un avertissement à l'utilisateur |
| Ingénieur Son | Peut ajuster les créneaux temporels pour optimiser |

**Reprise** : Retour au scénario nominal avec créneaux ajustés

### Scénario alternatif 4: Échec de calcul d'intermodulation

**Condition initiale** : Erreur dans le calcul des produits d'intermodulation
**Déclenchement** : Exception lors de CalculAllIntermod()
**Actions** :

| Acteur | Action |
|--------|--------|
| Système | Détecte l'échec du calcul d'intermodulation |
| Système | Log l'erreur dans le système de debug |
| Système | Applique un calcul RF simplifié sans intermodulation |
| Système | Affiche un avertissement à l'utilisateur |
| Système | Permet de continuer avec des fréquences sous-optimales |

**Reprise** : Continuation avec plan RF dégradé

## Diagramme de séquence

```mermaid
sequenceDiagram
    participant IS as Ingénieur Son
    participant UI as Interface
    participant FCS as FrequencyCalculationService
    participant GVM as GroupsViewModel
    participant RFG1 as RFGroup1
    participant RFG2 as RFGroup2
    participant TP1 as TimePeriod1
    participant TP2 as TimePeriod2
    participant DVM as DevicesViewModel

    IS->>UI: Lance calcul RF
    UI->>FCS: CalculateFrequenciesAsync()
    FCS->>FCS: FindOverlappingGroups()
    
    FCS->>GVM: Récupère _groupsViewModel.Groups
    GVM-->>FCS: Liste de tous les groupes
    
    loop Pour chaque paire de groupes
        FCS->>FCS: DoGroupsOverlap(group1, group2)
        FCS->>RFG1: Récupère TimePeriods
        RFG1-->>FCS: Liste des périodes groupe1
        FCS->>RFG2: Récupère TimePeriods
        RFG2-->>FCS: Liste des périodes groupe2
        
        loop Pour chaque paire de périodes
            FCS->>TP1: StartTime, EndTime
            FCS->>TP2: StartTime, EndTime
            FCS->>FCS: DoPeriodsOverlap(period1, period2)
            Note over FCS: period1.StartTime < period2.EndTime<br/>&& period1.EndTime > period2.StartTime
        end
        
        alt Chevauchement détecté
            FCS->>FCS: Ajouter au même overlappingSet
        else Pas de chevauchement
            FCS->>FCS: Créer overlappingSet séparé
        end
    end
    
    loop Pour chaque overlappingSet
        FCS->>FCS: GetDevicesForGroupSet(groupSet)
        FCS->>DVM: Filter devices by GroupID
        DVM-->>FCS: Équipements du groupe
        
        Note over FCS: Passe 1: Fréquences verrouillées
        FCS->>FCS: Process IsLocked channels
        
        Note over FCS: Passe 2: Fréquences libres
        FCS->>FCS: SetRandomFrequency() pour canaux libres
        
        Note over FCS: Passe 3: Fréquences de secours
        FCS->>FCS: Generate backup frequencies
        
        FCS->>FCS: Assign group color
        FCS->>FCS: Store groupFrequencyData
    end
    
    FCS->>DVM: SaveAllDevicesAsync()
    FCS->>FCS: SaveFrequencyDataAsync()
    FCS-->>UI: Calcul terminé
    UI-->>IS: Plan RF optimisé affiché
```

## Diagramme d'activité

```mermaid
flowchart TD
    A[Début calcul RF] --> B[Initialiser overlappingGroups]
    B --> C[Récupérer tous les groupes]
    C --> D[Début analyse chevauchements]
    
    D --> E{Groupe déjà traité?}
    E -->|Oui| F[Groupe suivant]
    E -->|Non| G[Créer nouvel overlappingSet]
    
    G --> H[Ajouter groupe à l'ensemble]
    H --> I[Marquer groupe comme traité]
    I --> J[Analyser autres groupes]
    
    J --> K{Chevauchement détecté?}
    K -->|Oui| L[DoGroupsOverlap]
    L --> M[Comparer toutes les TimePeriods]
    M --> N{DoPeriodsOverlap?}
    N -->|Oui| O[Ajouter à l'overlappingSet]
    N -->|Non| P[Groupe suivant pour comparaison]
    
    P --> R{Autres groupes à vérifier?}
    R -->|Oui| K
    R -->|Non| S[Finaliser overlappingSet]
    
    S --> T{Autres groupes non traités?}
    T -->|Oui| E
    T -->|Non| U[Commencer calcul RF par ensemble]
    
    U --> V[Sélectionner overlappingSet]
    V --> W[GetDevicesForGroupSet]
    W --> X[Initialiser FrequencyData pour le groupe]
    
    X --> Y[Passe 1: Fréquences verrouillées]
    Y --> Z[Traiter IsLocked = true]
    Z --> AA[SetRandomFrequency avec contraintes]
    
    AA --> BB[Passe 2: Fréquences libres]
    BB --> CC[Traiter canaux non verrouillés]
    CC --> DD[Calcul intermodulation]
    DD --> EE[Allocation fréquences optimales]
    
    EE --> FF[Passe 3: Fréquences de secours]
    FF --> GG[Générer backup frequencies]
    GG --> HH[Assigner couleur au groupe]
    
    HH --> II{Autres overlappingSets?}
    II -->|Oui| V
    II -->|Non| JJ[Sauvegarder tous les devices]
    
    JJ --> KK[Sauvegarder FrequencyData]
    KK --> LL[Mettre à jour affichage]
    LL --> MM[Fin]
    
    F --> R
```

## Points d'extension

- Pas de modifications futures prévues

## Contraintes techniques

- L'algorithme DoPeriodsOverlap() utilise la logique : `StartTime1 < EndTime2 && EndTime1 > StartTime2`
- Les groupes sont traités via un HashSet pour éviter les doublons
- Les couleurs sont assignées cycliquement via un tableau prédéfini (10 couleurs)
- La performance est optimisée par le traitement par clusters d'overlapping
- Les TimePeriods sont sérialisées en JSON pour le stockage SQLite
