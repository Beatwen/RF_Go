"use strict";(self.webpackChunkrf_go_docs=self.webpackChunkrf_go_docs||[]).push([[8049],{686:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"features/time-management","title":"Gestion temporelle - planification RF avanc\xe9e","description":"La gestion temporelle est une fonctionnalit\xe9 distinctive de RF.Go qui permet de planifier l\'utilisation des fr\xe9quences dans le temps. Cette approche optimise l\'utilisation du spectre en calculant des \xe9tapes de fr\xe9quences par paires selon les superpositions temporelles r\xe9elles.","source":"@site/docs/features/time-management.md","sourceDirName":"features","slug":"/features/time-management","permalink":"/RF_Go/features/time-management","draft":false,"unlisted":false,"editUrl":"https://github.com/Beatwen/RF_Go/tree/main/docs/features/time-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gestion des Fr\xe9quences","permalink":"/RF_Go/features/frequency-management"},"next":{"title":"Visualisation des fr\xe9quences","permalink":"/RF_Go/features/frequency-visualization"}}');var i=n(4848),t=n(8453);const l={},a="Gestion temporelle - planification RF avanc\xe9e",o={},u=[{value:"Vue d&#39;ensemble",id:"vue-densemble",level:2},{value:"Concept de la gestion temporelle",id:"concept-de-la-gestion-temporelle",level:3},{value:"Architecture temporelle",id:"architecture-temporelle",level:2},{value:"Mod\xe8le de donn\xe9es",id:"mod\xe8le-de-donn\xe9es",level:3},{value:"Types de superpositions temporelles",id:"types-de-superpositions-temporelles",level:3},{value:"1. <strong>Superposition simple</strong>",id:"1-superposition-simple",level:4},{value:"2. <strong>Superposition multiple</strong>",id:"2-superposition-multiple",level:4},{value:"3. <strong>Groupes isol\xe9s</strong>",id:"3-groupes-isol\xe9s",level:4},{value:"Algorithme de calcul temporel",id:"algorithme-de-calcul-temporel",level:2},{value:"G\xe9n\xe9ration des \xe9tapes de calcul",id:"g\xe9n\xe9ration-des-\xe9tapes-de-calcul",level:3},{value:"Algorithme de calcul par \xe9tapes",id:"algorithme-de-calcul-par-\xe9tapes",level:3},{value:"Interface utilisateur temporelle",id:"interface-utilisateur-temporelle",level:2},{value:"Affichage SciChart par \xe9tapes",id:"affichage-scichart-par-\xe9tapes",level:3},{value:"Exemples de r\xe9sultats",id:"exemples-de-r\xe9sultats",level:3},{value:"Sc\xe9nario 1: Groupes s\xe9quentiels",id:"sc\xe9nario-1-groupes-s\xe9quentiels",level:4},{value:"Sc\xe9nario 2: Superpositions Multiples",id:"sc\xe9nario-2-superpositions-multiples",level:4},{value:"Sc\xe9nario 3: Superposition",id:"sc\xe9nario-3-superposition",level:4},{value:"Avantages de cette approche",id:"avantages-de-cette-approche",level:2},{value:"\ud83c\udfaf <strong>Optimisation</strong>",id:"-optimisation",level:3},{value:"\ud83c\udfa8 <strong>Visualisation</strong>",id:"-visualisation",level:3},{value:"\u26a1 <strong>Performance</strong>",id:"-performance",level:3},{value:"\ud83d\udd27 <strong>Flexibilit\xe9e</strong>",id:"-flexibilit\xe9e",level:3}];function p(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"gestion-temporelle---planification-rf-avanc\xe9e",children:"Gestion temporelle - planification RF avanc\xe9e"})}),"\n",(0,i.jsxs)(r.p,{children:["La ",(0,i.jsx)(r.strong,{children:"gestion temporelle"})," est une fonctionnalit\xe9 distinctive de RF.Go qui permet de planifier l'utilisation des fr\xe9quences dans le temps. Cette approche optimise l'utilisation du spectre en calculant des ",(0,i.jsx)(r.strong,{children:"\xe9tapes de fr\xe9quences par paires"})," selon les superpositions temporelles r\xe9elles."]}),"\n",(0,i.jsx)(r.h2,{id:"vue-densemble",children:"Vue d'ensemble"}),"\n",(0,i.jsx)(r.h3,{id:"concept-de-la-gestion-temporelle",children:"Concept de la gestion temporelle"}),"\n",(0,i.jsxs)(r.p,{children:["La gestion temporelle dans RF.Go repose sur le principe que ",(0,i.jsx)(r.strong,{children:"les superpositions temporelles g\xe9n\xe8rent des \xe9tapes de calcul optimis\xe9es"}),". Au lieu de calculer tous les groupes ensemble, le syst\xe8me :"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Analyse les superpositions chronologiques"})," entre groupes"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"G\xe9n\xe8re des \xe9tapes de calcul par paires"}),' (ex: "Groupe A & B", "Groupe B & C")']}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Optimise les intermodulations"})," pour chaque combinaison temporelle"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Permet la visualisation s\xe9par\xe9e"})," des plans de fr\xe9quences par \xe9tape"]}),"\n"]}),"\n",(0,i.jsx)(r.mermaid,{value:"gantt\r\n    title Exemple de Planification Temporelle RF avec \xc9tapes de Calcul\r\n    dateFormat HH:mm\r\n    axisFormat %H:%M\r\n    \r\n    section Sc\xe8ne Principale\r\n    AC/DC               :active, artist-a, 18:00, 19:00\r\n    Katie Melua         :artist-b, 18:40, 20:00\r\n    Bruce Springsteen   :artist-c, 19:35, 20:55\r\n    \r\n    section \xc9tapes de Calcul G\xe9n\xe9r\xe9es\r\n    AC/DC & Katie Melua      :crit, step1, 18:40, 19:00\r\n    Katie Melua & Bruce      :crit, step2, 19:35, 20:00\r\n    \r\n    section R\xe9sultat SciChart\r\n    Plan Fr\xe9quences 1   :done, plan1, 18:00, 20:00\r\n    Plan Fr\xe9quences 2   :done, plan2, 18:40, 20:55"}),"\n",(0,i.jsx)(r.h2,{id:"architecture-temporelle",children:"Architecture temporelle"}),"\n",(0,i.jsx)(r.h3,{id:"mod\xe8le-de-donn\xe9es",children:"Mod\xe8le de donn\xe9es"}),"\n",(0,i.jsx)(r.mermaid,{value:"erDiagram\r\n    RFGroup {\r\n        int ID\r\n        string Name\r\n        string TimePeriodsSerialized\r\n        List_TimePeriod TimePeriods\r\n    }\r\n    \r\n    TimePeriod {\r\n        int ID\r\n        string Name\r\n        DateTime StartTime\r\n        DateTime EndTime\r\n        TimeSpan StartTimeSpan\r\n        TimeSpan EndTimeSpan\r\n        DateRange Range\r\n    }\r\n    \r\n    GroupCalculationStep {\r\n        List_RFGroup GroupsToCalculate\r\n        List_int PreserveFrequenciesFromGroups\r\n        string StepName\r\n    }\r\n    \r\n    CalculationStepData {\r\n        string StepName\r\n        FrequencyData FrequencyData\r\n        string Color\r\n        HashSet_int UsedFrequencies\r\n        HashSet_int IntermodulationData\r\n    }\r\n    \r\n    RFDevice {\r\n        int ID\r\n        string Name\r\n        int GroupID\r\n        List_RFChannel Channels\r\n    }\r\n    \r\n    RFChannel {\r\n        int ID\r\n        int Frequency\r\n        bool IsLocked\r\n        string ChannelName\r\n    }\r\n    \r\n    RFGroup ||--o{ TimePeriod : contains\r\n    RFGroup ||--o{ RFDevice : contains\r\n    RFDevice ||--o{ RFChannel : contains\r\n    GroupCalculationStep ||--o{ RFGroup : processes\r\n    CalculationStepData ||--|| GroupCalculationStep : results_from"}),"\n",(0,i.jsx)(r.h3,{id:"types-de-superpositions-temporelles",children:"Types de superpositions temporelles"}),"\n",(0,i.jsxs)(r.h4,{id:"1-superposition-simple",children:["1. ",(0,i.jsx)(r.strong,{children:"Superposition simple"})]}),"\n",(0,i.jsx)(r.p,{children:"Deux groupes se chevauchent dans le temps :"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// Exemple: AC/DC (18:00-19:00) + Katie Melua (18:40-20:00)\r\n// R\xe9sultat: \xc9tape "AC/DC & Katie Melua"\r\nvar etapeSimple = new GroupCalculationStep {\r\n    GroupsToCalculate = { groupACDC, groupKatieMelua },\r\n    PreserveFrequenciesFromGroups = { },\r\n    StepName = "AC/DC & Katie Melua"\r\n};\n'})}),"\n",(0,i.jsxs)(r.h4,{id:"2-superposition-multiple",children:["2. ",(0,i.jsx)(r.strong,{children:"Superposition multiple"})]}),"\n",(0,i.jsx)(r.p,{children:"Un groupe se superpose avec plusieurs autres \xe0 des moments diff\xe9rents :"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// Katie Melua se superpose avec AC/DC puis avec Bruce Springsteen\r\n// R\xe9sultat: \r\n// \xc9tape 1: "AC/DC & Katie Melua" \r\n// \xc9tape 2: "Katie Melua & Bruce Springsteen"\n'})}),"\n",(0,i.jsxs)(r.h4,{id:"3-groupes-isol\xe9s",children:["3. ",(0,i.jsx)(r.strong,{children:"Groupes isol\xe9s"})]}),"\n",(0,i.jsx)(r.p,{children:"Groupes sans superposition temporelle :"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'// Groupe seul sans chevauchement\r\n// R\xe9sultat: \xc9tape "Nom du Groupe"\n'})}),"\n",(0,i.jsx)(r.h2,{id:"algorithme-de-calcul-temporel",children:"Algorithme de calcul temporel"}),"\n",(0,i.jsx)(r.h3,{id:"g\xe9n\xe9ration-des-\xe9tapes-de-calcul",children:"G\xe9n\xe9ration des \xe9tapes de calcul"}),"\n",(0,i.jsxs)(r.p,{children:["L'algorithme ",(0,i.jsx)(r.code,{children:"BuildGroupCalculationPlan()"})," analyse intelligemment les superpositions :"]}),"\n",(0,i.jsx)(r.mermaid,{value:"graph TD\r\n    A[Charger Tous les Groupes] --\x3e B[Trier par Ordre Chronologique]\r\n    B --\x3e C[Pour Chaque Groupe]\r\n    C --\x3e D[Identifier Groupes qui se Superposent]\r\n    \r\n    D --\x3e E{Superpositions D\xe9tect\xe9es ?}\r\n    E --\x3e|Oui| F[Cr\xe9er \xc9tapes par Paires]\r\n    E --\x3e|Non| G[Traiter Groupe Seul]\r\n    \r\n    F --\x3e H[G\xe9n\xe9rer Nom d'\xc9tape Dynamique]\r\n    G --\x3e I[Nom Simple du Groupe]\r\n    \r\n    H --\x3e J[Calculer Fr\xe9quences pour l'\xc9tape]\r\n    I --\x3e J\r\n    \r\n    J --\x3e K[Stocker R\xe9sultats par \xc9tape]\r\n    K --\x3e L[Afficher dans SciChart]\r\n    \r\n    style F fill:#e3f2fd\r\n    style H fill:#f3e5f5\r\n    style J fill:#e8f5e8\r\n    style L fill:#fff3e0"}),"\n",(0,i.jsx)(r.h3,{id:"algorithme-de-calcul-par-\xe9tapes",children:"Algorithme de calcul par \xe9tapes"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'public class TemporalFrequencyCalculator \r\n{\r\n    public async Task CalculateFrequenciesAsync()\r\n    {\r\n        // 1. Construire le plan de calcul par \xe9tapes\r\n        var groupCalculationPlan = BuildGroupCalculationPlan();\r\n        var calculationStepData = new Dictionary<string, FrequencyData>();\r\n        \r\n        foreach (var calculationStep in groupCalculationPlan)\r\n        {\r\n            // 2. Pr\xe9parer les donn\xe9es de base pour cette \xe9tape\r\n            var groupData = new FrequencyData();\r\n            \r\n            // 3. Copier fr\xe9quences des groupes pr\xe9serv\xe9s (si applicable)\r\n            CopyPreservedFrequencies(calculationStep, groupData);\r\n            \r\n            // 4. Calculer nouvelles fr\xe9quences pour cette \xe9tape\r\n            var devicesInGroups = GetDevicesForGroupSet(calculationStep.GroupsToCalculate);\r\n            CalculateStepFrequencies(devicesInGroups, groupData);\r\n            \r\n            // 5. G\xe9n\xe9rer nom d\'\xe9tape dynamique\r\n            var stepName = CreateCalculationStepName(calculationStep);\r\n            // R\xe9sultat: "AC/DC & Katie Melua" ou "Bruce Springsteen"\r\n            \r\n            // 6. Stocker les r\xe9sultats avec couleur unique\r\n            calculationStepData[stepName] = groupData;\r\n        }\r\n        \r\n        // 7. Convertir pour affichage SciChart\r\n        UpdateSciChartVisualization(calculationStepData);\r\n    }\r\n    \r\n    private List<GroupCalculationStep> BuildGroupCalculationPlan()\r\n    {\r\n        var sortedGroups = _groupsViewModel.Groups\r\n            .Where(g => g.TimePeriods != null && g.TimePeriods.Any())\r\n            .OrderBy(g => g.TimePeriods.Min(tp => tp.StartTime))\r\n            .ToList();\r\n\r\n        var calculationPlan = new List<GroupCalculationStep>();\r\n        var processedGroupCombinations = new HashSet<string>();\r\n\r\n        foreach (var group in sortedGroups)\r\n        {\r\n            // Trouver tous les groupes qui se superposent avec ce groupe\r\n            var overlappingGroups = FindOverlappingGroups(group);\r\n            \r\n            // Pour chaque superposition, cr\xe9er une \xe9tape de calcul\r\n            foreach (var overlappingGroup in overlappingGroups)\r\n            {\r\n                // Traiter seulement si ce groupe commence avant l\'autre (ordre chronologique)\r\n                if (group.StartTime <= overlappingGroup.StartTime)\r\n                {\r\n                    var combinationKey = $"{Math.Min(group.ID, overlappingGroup.ID)}-{Math.Max(group.ID, overlappingGroup.ID)}";\r\n                    \r\n                    if (!processedGroupCombinations.Contains(combinationKey))\r\n                    {\r\n                        var step = new GroupCalculationStep\r\n                        {\r\n                            GroupsToCalculate = new List<RFGroup> { group, overlappingGroup },\r\n                            PreserveFrequenciesFromGroups = new List<int>()\r\n                        };\r\n\r\n                        calculationPlan.Add(step);\r\n                        processedGroupCombinations.Add(combinationKey);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Si pas de superposition, traiter le groupe seul\r\n            if (overlappingGroups.Count == 0)\r\n            {\r\n                calculationPlan.Add(new GroupCalculationStep\r\n                {\r\n                    GroupsToCalculate = new List<RFGroup> { group },\r\n                    PreserveFrequenciesFromGroups = new List<int>()\r\n                });\r\n            }\r\n        }\r\n\r\n        return calculationPlan;\r\n    }\r\n    \r\n    private string CreateCalculationStepName(GroupCalculationStep calculationStep)\r\n    {\r\n        var groupNames = calculationStep.GroupsToCalculate\r\n            .Select(g => g.Name)\r\n            .ToList();\r\n\r\n        if (groupNames.Count == 1)\r\n        {\r\n            return groupNames[0];  // "Bruce Springsteen"\r\n        }\r\n        else\r\n        {\r\n            return string.Join(" & ", groupNames);  // "AC/DC & Katie Melua"\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"interface-utilisateur-temporelle",children:"Interface utilisateur temporelle"}),"\n",(0,i.jsx)(r.h3,{id:"affichage-scichart-par-\xe9tapes",children:"Affichage SciChart par \xe9tapes"}),"\n",(0,i.jsx)(r.mermaid,{value:'graph LR\r\n    subgraph "SciChart Visualization"\r\n        A[L\xe9gende Interactive]\r\n        B[Plan Fr\xe9quences par \xc9tape]\r\n        C[Couleurs Distinctes]\r\n        D[Intermodulations par \xc9tape]\r\n    end\r\n    \r\n    subgraph "\xc9tapes G\xe9n\xe9r\xe9es"\r\n        E["AC/DC & Katie Melua"]\r\n        F["Katie Melua & Bruce Springsteen"] \r\n        G["Autre Groupe Seul"]\r\n    end\r\n    \r\n    E --\x3e A\r\n    F --\x3e A\r\n    G --\x3e A\r\n    A --\x3e B\r\n    B --\x3e C\r\n    C --\x3e D\r\n    \r\n    style E fill:#e3f2fd\r\n    style F fill:#f3e5f5\r\n    style G fill:#e8f5e8'}),"\n",(0,i.jsx)(r.h3,{id:"exemples-de-r\xe9sultats",children:"Exemples de r\xe9sultats"}),"\n",(0,i.jsx)(r.h4,{id:"sc\xe9nario-1-groupes-s\xe9quentiels",children:"Sc\xe9nario 1: Groupes s\xe9quentiels"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'Groupe A: 14:00-15:00\r\nGroupe B: 16:00-17:00\r\nGroupe C: 18:00-19:00\r\n\r\nR\xe9sultat SciChart:\r\n- "Groupe A" (couleur 1)\r\n- "Groupe B" (couleur 2) \r\n- "Groupe C" (couleur 3)\n'})}),"\n",(0,i.jsx)(r.h4,{id:"sc\xe9nario-2-superpositions-multiples",children:"Sc\xe9nario 2: Superpositions Multiples"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'AC/DC:           18:00 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 19:00\r\nKatie Melua:          18:40 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 20:00\r\nBruce Springsteen:              19:35 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 20:55\r\n\r\nR\xe9sultat SciChart:\r\n- "AC/DC & Katie Melua" (couleur 1) - Intermod combin\xe9es \r\n- "Katie Melua & Bruce Springsteen" (couleur 2) - Intermod combin\xe9es\n'})}),"\n",(0,i.jsx)(r.h4,{id:"sc\xe9nario-3-superposition",children:"Sc\xe9nario 3: Superposition"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'Groupe 1: 14:00-16:00\r\nGroupe 2: 15:00-17:00  (chevauche avec 1 et 3)\r\nGroupe 3: 16:30-18:00\r\n\r\nR\xe9sultat SciChart:\r\n- "Groupe 1 & Groupe 2" (couleur 1)\r\n- "Groupe 2 & Groupe 3" (couleur 2)\n'})}),"\n",(0,i.jsx)(r.h2,{id:"avantages-de-cette-approche",children:"Avantages de cette approche"}),"\n",(0,i.jsxs)(r.h3,{id:"-optimisation",children:["\ud83c\udfaf ",(0,i.jsx)(r.strong,{children:"Optimisation"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Chaque \xe9tape de calcul correspond \xe0 une ",(0,i.jsx)(r.strong,{children:"superposition temporelle r\xe9elle"})]}),"\n",(0,i.jsxs)(r.li,{children:["Les intermodulations sont calcul\xe9es uniquement pour les ",(0,i.jsx)(r.strong,{children:"groupes actifs simultan\xe9ment"})]}),"\n",(0,i.jsx)(r.li,{children:"\xc9vite les calculs inutiles pour groupes non-superpos\xe9s"}),"\n"]}),"\n",(0,i.jsxs)(r.h3,{id:"-visualisation",children:["\ud83c\udfa8 ",(0,i.jsx)(r.strong,{children:"Visualisation"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"L\xe9gende explicite"}),' : "Groupe A & B" au lieu de groupes s\xe9par\xe9s']}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Couleurs distinctes"})," pour chaque \xe9tape de calcul"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Compr\xe9hension intuitive"})," des combinaisons temporelles"]}),"\n"]}),"\n",(0,i.jsxs)(r.h3,{id:"-performance",children:["\u26a1 ",(0,i.jsx)(r.strong,{children:"Performance"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Calcul s\xe9quentiel"})," au lieu de calcul global massif"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"R\xe9utilisation intelligente"})," des r\xe9sultats entre \xe9tapes"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"\xc9vitement des recalculs"})," redondants"]}),"\n"]}),"\n",(0,i.jsxs)(r.h3,{id:"-flexibilit\xe9e",children:["\ud83d\udd27 ",(0,i.jsx)(r.strong,{children:"Flexibilit\xe9e"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Support des configurations complexes"})," avec multiples superpositions"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Adaptation automatique"})," aux changements de planning"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"\xc9volutivit\xe9"})," pour \xe9v\xe9nements de toute taille"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Cette approche r\xe9volutionnaire transforme la gestion temporelle RF en un syst\xe8me intelligent qui ",(0,i.jsx)(r.strong,{children:"comprend et optimise automatiquement"})," les besoins r\xe9els de chaque configuration temporelle."]})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var s=n(6540);const i={},t=s.createContext(i);function l(e){const r=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);