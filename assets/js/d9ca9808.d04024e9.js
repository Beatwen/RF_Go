"use strict";(self.webpackChunkrf_go_docs=self.webpackChunkrf_go_docs||[]).push([[8049],{686:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"features/time-management","title":"Gestion temporelle - Planification RF avanc\xe9e","description":"La gestion temporelle est une fonctionnalit\xe9 distinctive de RF.Go qui permet de planifier l\'utilisation des fr\xe9quences dans le temps. Cette approche optimise l\'utilisation du spectre en permettant la r\xe9utilisation des fr\xe9quences selon les cr\xe9neaux horaires.","source":"@site/docs/features/time-management.md","sourceDirName":"features","slug":"/features/time-management","permalink":"/RF_Go/features/time-management","draft":false,"unlisted":false,"editUrl":"https://github.com/Beatwen/RF_Go/tree/main/docs/features/time-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gestion des Fr\xe9quences","permalink":"/RF_Go/features/frequency-management"},"next":{"title":"Visualisation des Fr\xe9quences","permalink":"/RF_Go/features/frequency-visualization"}}');var s=n(4848),t=n(8453);const l={},o="Gestion temporelle - Planification RF avanc\xe9e",a={},c=[{value:"Vue d&#39;ensemble",id:"vue-densemble",level:2},{value:"Concept de la gestion temporelle",id:"concept-de-la-gestion-temporelle",level:3},{value:"Architecture temporelle",id:"architecture-temporelle",level:2},{value:"Mod\xe8le de donn\xe9es",id:"mod\xe8le-de-donn\xe9es",level:3},{value:"Types de p\xe9riodes temporelles",id:"types-de-p\xe9riodes-temporelles",level:3},{value:"1. <strong>P\xe9riodes Fixes</strong>",id:"1-p\xe9riodes-fixes",level:4},{value:"Algorithme de calcul temporel",id:"algorithme-de-calcul-temporel",level:2},{value:"D\xe9tection des conflits temporels",id:"d\xe9tection-des-conflits-temporels",level:3},{value:"Algorithme de r\xe9utilisation",id:"algorithme-de-r\xe9utilisation",level:3},{value:"Interface Utilisateur Temporelle",id:"interface-utilisateur-temporelle",level:2},{value:"\xc9diteur de P\xe9riodes Temporelles",id:"\xe9diteur-de-p\xe9riodes-temporelles",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"gestion-temporelle---planification-rf-avanc\xe9e",children:"Gestion temporelle - Planification RF avanc\xe9e"})}),"\n",(0,s.jsxs)(r.p,{children:["La ",(0,s.jsx)(r.strong,{children:"gestion temporelle"})," est une fonctionnalit\xe9 distinctive de RF.Go qui permet de planifier l'utilisation des fr\xe9quences dans le temps. Cette approche optimise l'utilisation du spectre en permettant la r\xe9utilisation des fr\xe9quences selon les cr\xe9neaux horaires."]}),"\n",(0,s.jsx)(r.h2,{id:"vue-densemble",children:"Vue d'ensemble"}),"\n",(0,s.jsx)(r.h3,{id:"concept-de-la-gestion-temporelle",children:"Concept de la gestion temporelle"}),"\n",(0,s.jsxs)(r.p,{children:["La gestion temporelle dans RF.Go repose sur le principe que ",(0,s.jsx)(r.strong,{children:"toutes les fr\xe9quences ne sont pas n\xe9cessaires simultan\xe9ment"})," lors d'un \xe9v\xe9nement. En organisant les appareils en groupes temporels, il devient possible de :"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"R\xe9utiliser les m\xeames fr\xe9quences"})," \xe0 des moments diff\xe9rents"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Optimiser l'occupation du spectre"})," disponible"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"G\xe9rer les changements de sc\xe8ne"})," automatiquement"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Planifier les transitions"})," entre configurations"]}),"\n"]}),"\n",(0,s.jsx)(r.mermaid,{value:"gantt\r\n    title Exemple de Planification Temporelle RF\r\n    dateFormat HH:mm\r\n    axisFormat %H:%M\r\n    \r\n    section Sc\xe8ne Principale\r\n    Groupe Artiste A    :active, artist-a, 14:00, 15:30\r\n    Groupe Artiste B    :artist-b, 16:00, 17:30\r\n    Groupe Artiste C    :artist-c, 18:00, 19:30\r\n    \r\n    section Sc\xe8ne Secondaire\r\n    Interview          :interview, 14:30, 15:00\r\n    Talk Show          :talk, 15:45, 16:15\r\n    Podcast Live       :podcast, 17:45, 18:15\r\n    \r\n    section R\xe9gie G\xe9n\xe9rale\r\n    Coordination       :crit, coord, 14:00, 20:00\r\n    Secours            :backup, 14:00, 20:00"}),"\n",(0,s.jsx)(r.h2,{id:"architecture-temporelle",children:"Architecture temporelle"}),"\n",(0,s.jsx)(r.h3,{id:"mod\xe8le-de-donn\xe9es",children:"Mod\xe8le de donn\xe9es"}),"\n",(0,s.jsx)(r.mermaid,{value:"erDiagram\r\n    RFGroup {\r\n        int ID\r\n        string Name\r\n        string TimePeriodsSerialized\r\n        List_TimePeriod TimePeriods\r\n    }\r\n    \r\n    TimePeriod {\r\n        int ID\r\n        string Name\r\n        DateTime StartTime\r\n        DateTime EndTime\r\n        TimeSpan StartTimeSpan\r\n        TimeSpan EndTimeSpan\r\n        DateRange Range\r\n    }\r\n    \r\n    RFDevice {\r\n        int ID\r\n        string Name\r\n        int GroupID\r\n        List_RFChannel Channels\r\n    }\r\n    \r\n    RFChannel {\r\n        int ID\r\n        int Frequency\r\n        bool IsLocked\r\n        string ChannelName\r\n    }\r\n    \r\n    RFGroup ||--o{ TimePeriod : contains\r\n    RFGroup ||--o{ RFDevice : contains\r\n    RFDevice ||--o{ RFChannel : contains"}),"\n",(0,s.jsx)(r.h3,{id:"types-de-p\xe9riodes-temporelles",children:"Types de p\xe9riodes temporelles"}),"\n",(0,s.jsxs)(r.h4,{id:"1-p\xe9riodes-fixes",children:["1. ",(0,s.jsx)(r.strong,{children:"P\xe9riodes Fixes"})]}),"\n",(0,s.jsx)(r.p,{children:"Cr\xe9neaux horaires d\xe9finis avec d\xe9but et fin pr\xe9cis :"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-csharp",children:'var periodeFixe = new TimePeriod {\r\n    Name = "Concert Principal",\r\n    StartTime = new DateTime(2024, 06, 15, 20, 00, 00),\r\n    EndTime = new DateTime(2024, 06, 15, 22, 30, 00)\r\n};\n'})}),"\n",(0,s.jsx)(r.h2,{id:"algorithme-de-calcul-temporel",children:"Algorithme de calcul temporel"}),"\n",(0,s.jsx)(r.h3,{id:"d\xe9tection-des-conflits-temporels",children:"D\xe9tection des conflits temporels"}),"\n",(0,s.jsx)(r.p,{children:"L'algorithme analyse les chevauchements temporels pour optimiser la r\xe9utilisation des fr\xe9quences :"}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TD\r\n    A[Charger Tous les Groupes] --\x3e B[Analyser Chevauchements Temporels]\r\n    B --\x3e C{Groupes se Chevauchent ?}\r\n    \r\n    C --\x3e|Oui| D[Cr\xe9er Groupe de Calcul Combin\xe9]\r\n    C --\x3e|Non| E[Traiter Groupes S\xe9par\xe9ment]\r\n    \r\n    D --\x3e F[Calculer Fr\xe9quences pour Tous Appareils]\r\n    E --\x3e G[Calculer Fr\xe9quences par Groupe]\r\n    \r\n    F --\x3e H[R\xe9utiliser Fr\xe9quences Entre P\xe9riodes]\r\n    G --\x3e H\r\n    \r\n    H --\x3e I[Optimiser Transitions]\r\n    I --\x3e J[G\xe9n\xe9rer Plan Temporel]\r\n    \r\n    style D fill:#ffcdd2\r\n    style H fill:#c8e6c9\r\n    style J fill:#e1f5fe"}),"\n",(0,s.jsx)(r.h3,{id:"algorithme-de-r\xe9utilisation",children:"Algorithme de r\xe9utilisation"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-csharp",children:"public class TemporalFrequencyCalculator \r\n{\r\n    public void CalculateTemporalFrequencies(List<RFGroup> groups)\r\n    {\r\n        // 1. Analyser les chevauchements temporels\r\n        var groupSets = AnalyzeTemporalOverlaps(groups);\r\n        \r\n        foreach (var groupSet in groupSets)\r\n        {\r\n            if (groupSet.HasOverlaps)\r\n            {\r\n                // Calcul combin\xe9 pour groupes qui se chevauchent\r\n                CalculateCombinedFrequencies(groupSet.Groups);\r\n            }\r\n            else\r\n            {\r\n                // R\xe9utilisation des fr\xe9quences entre p\xe9riodes distinctes\r\n                ReuseFrequenciesAcrossPeriods(groupSet.Groups);\r\n            }\r\n        }\r\n        \r\n        // 2. Optimiser les transitions entre p\xe9riodes\r\n        OptimizeTransitions(groupSets);\r\n    }\r\n    \r\n    private void ReuseFrequenciesAcrossPeriods(List<RFGroup> sequentialGroups)\r\n    {\r\n        var availableFrequencies = new List<int>();\r\n        \r\n        foreach (var group in sequentialGroups.OrderBy(g => g.TimePeriods.First().StartTime))\r\n        {\r\n            // R\xe9utiliser les fr\xe9quences des groupes pr\xe9c\xe9dents\r\n            AssignFrequenciesFromPool(group, availableFrequencies);\r\n            \r\n            // Ajouter les nouvelles fr\xe9quences au pool\r\n            availableFrequencies.AddRange(GetGroupFrequencies(group));\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"interface-utilisateur-temporelle",children:"Interface Utilisateur Temporelle"}),"\n",(0,s.jsx)(r.h3,{id:"\xe9diteur-de-p\xe9riodes-temporelles",children:"\xc9diteur de P\xe9riodes Temporelles"}),"\n",(0,s.jsx)(r.mermaid,{value:'graph LR\r\n    subgraph "Timeline Editor"\r\n        A[Barre Temporelle]\r\n        B[Groupes Visuels]\r\n        C[Conflits D\xe9tect\xe9s]\r\n        D[Zone de Transition]\r\n    end\r\n    \r\n    subgraph "Configuration Panel"\r\n        E[D\xe9but/Fin P\xe9riode]\r\n        F[Dur\xe9e/R\xe9currence]\r\n        G[Contraintes RF]\r\n        H[Fr\xe9quences Assign\xe9es]\r\n    end\r\n    \r\n    A --\x3e B\r\n    B --\x3e C\r\n    C --\x3e D\r\n    E --\x3e A\r\n    F --\x3e A\r\n    G --\x3e H\r\n    H --\x3e B\r\n    \r\n    style C fill:#ffcdd2\r\n    style D fill:#fff3e0'})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>o});var i=n(6540);const s={},t=i.createContext(s);function l(e){const r=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);