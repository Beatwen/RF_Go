"use strict";(self.webpackChunkrf_go_docs=self.webpackChunkrf_go_docs||[]).push([[2320],{3724:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"uml-analysis/state-diagrams","title":"Diagrammes d\'\xe9tats","description":"Les diagrammes d\'\xe9tats de RF.Go mod\xe9lisent le comportement des entit\xe9s principales bas\xe9 sur l\'analyse du code source. Ces mod\xe8les d\xe9crivent les transitions d\'\xe9tats effectivement impl\xe9ment\xe9es dans le syst\xe8me.","source":"@site/docs/uml-analysis/state-diagrams.md","sourceDirName":"uml-analysis","slug":"/uml-analysis/state-diagrams","permalink":"/RF_Go/uml-analysis/state-diagrams","draft":false,"unlisted":false,"editUrl":"https://github.com/Beatwen/RF_Go/tree/main/docs/uml-analysis/state-diagrams.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Diagrammes de classes","permalink":"/RF_Go/uml-analysis/class-diagrams"},"next":{"title":"Diagrammes de D\xe9ploiement","permalink":"/RF_Go/uml-analysis/deployment-diagrams"}}');var t=r(4848),i=r(8453);const a={},c="Diagrammes d'\xe9tats",d={},o=[{value:"1. Machine \xe0 \xe9tats d&#39;un appareil RF (RFDevice)",id:"1-machine-\xe0-\xe9tats-dun-appareil-rf-rfdevice",level:2},{value:"Cycle de vie complet bas\xe9 sur les propri\xe9t\xe9s IsSynced, IsOnline, PendingSync",id:"cycle-de-vie-complet-bas\xe9-sur-les-propri\xe9t\xe9s-issynced-isonline-pendingsync",level:3},{value:"2. \xc9tats de d\xe9couverte r\xe9seau",id:"2-\xe9tats-de-d\xe9couverte-r\xe9seau",level:2},{value:"Flux de d\xe9couverte multi-protocoles (DiscoveryService)",id:"flux-de-d\xe9couverte-multi-protocoles-discoveryservice",level:3},{value:"3. \xc9tats de monitoring (Timer 30 secondes)",id:"3-\xe9tats-de-monitoring-timer-30-secondes",level:2},{value:"CheckSingleDeviceSync - Machine \xe0 \xe9tats de v\xe9rification",id:"checksingledevicesync---machine-\xe0-\xe9tats-de-v\xe9rification",level:3},{value:"4. \xc9tats de synchronisation - Handler.IsDevicePendingSync",id:"4-\xe9tats-de-synchronisation---handlerisdevicependingsync",level:2},{value:"Logique de v\xe9rification Sennheiser/Shure",id:"logique-de-v\xe9rification-sennheisershure",level:3},{value:"5. \xc9tats de mapping - Processus MappingModal",id:"5-\xe9tats-de-mapping---processus-mappingmodal",level:2},{value:"Transformation DeviceDiscoveredEventArgs vers RFDevice",id:"transformation-devicediscoveredeventargs-vers-rfdevice",level:3},{value:"M\xe9triques de performance des \xe9tats",id:"m\xe9triques-de-performance-des-\xe9tats",level:2},{value:"Temps de transition mesur\xe9s",id:"temps-de-transition-mesur\xe9s",level:3},{value:"Contraintes d&#39;\xe9tats r\xe9elles",id:"contraintes-d\xe9tats-r\xe9elles",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"diagrammes-d\xe9tats",children:"Diagrammes d'\xe9tats"})}),"\n",(0,t.jsx)(n.p,{children:"Les diagrammes d'\xe9tats de RF.Go mod\xe9lisent le comportement des entit\xe9s principales bas\xe9 sur l'analyse du code source. Ces mod\xe8les d\xe9crivent les transitions d'\xe9tats effectivement impl\xe9ment\xe9es dans le syst\xe8me."}),"\n",(0,t.jsx)(n.h2,{id:"1-machine-\xe0-\xe9tats-dun-appareil-rf-rfdevice",children:"1. Machine \xe0 \xe9tats d'un appareil RF (RFDevice)"}),"\n",(0,t.jsx)(n.h3,{id:"cycle-de-vie-complet-bas\xe9-sur-les-propri\xe9t\xe9s-issynced-isonline-pendingsync",children:"Cycle de vie complet bas\xe9 sur les propri\xe9t\xe9s IsSynced, IsOnline, PendingSync"}),"\n",(0,t.jsx)(n.mermaid,{value:'stateDiagram-v2\r\n    [*] --\x3e Discovered : mDNS/SLP/UDP Discovery\r\n    \r\n    state "Device Discovered" as Discovered\r\n    state "Device Mapped" as Mapped  \r\n    state "Device Online" as Online\r\n    state "Device Offline" as Offline\r\n    \r\n    Discovered --\x3e Mapped : User clicks "Sync!" + MappingModal\r\n    Mapped --\x3e Online : CheckSingleDeviceSync (30s timer)\r\n    Online --\x3e Offline : IsNotResponding = true\r\n    Offline --\x3e Online : Device responds again\r\n    \r\n    note right of Discovered\r\n        DeviceDiscoveredEventArgs object\r\n        IsSynced = false\r\n        Stored in DiscoveryService.DiscoveredDevices\r\n        Displayed in OnlineTab\r\n    end note\r\n    \r\n    note right of Mapped\r\n        RFDevice object\r\n        IsSynced = true, IsOnline = true, PendingSync = false\r\n        CastDeviceDiscoveredToRFDevice()\r\n        AddItemAsync<RFDevice>() if ID = 0\r\n        UpdateItemAsync<RFDevice>() if ID != 0\r\n    end note\r\n    \r\n    note right of Online\r\n        IsSynced = true, IsOnline = true\r\n        PendingSync = false/true (depends on comparison)\r\n        Timer v\xe9rifie toutes les 30s\r\n        handler.IsDevicePendingSync()\r\n    end note\r\n    \r\n    note right of Offline\r\n        IsSynced = true, IsOnline = false\r\n        PendingSync = N/A (not checked when offline)\r\n        Device not responding to network calls\r\n    end note'}),"\n",(0,t.jsx)(n.h2,{id:"2-\xe9tats-de-d\xe9couverte-r\xe9seau",children:"2. \xc9tats de d\xe9couverte r\xe9seau"}),"\n",(0,t.jsx)(n.h3,{id:"flux-de-d\xe9couverte-multi-protocoles-discoveryservice",children:"Flux de d\xe9couverte multi-protocoles (DiscoveryService)"}),"\n",(0,t.jsx)(n.mermaid,{value:'stateDiagram-v2\r\n    [*] --\x3e Idle\r\n    \r\n    state "Discovery Idle" as Idle\r\n    state "Discovery Running" as Running\r\n    state "Devices Found" as Found\r\n    \r\n    Idle --\x3e Running : StartDiscovery()\r\n    \r\n    state Running {\r\n        [*] --\x3e ParallelDiscovery\r\n        \r\n        state ParallelDiscovery {\r\n            state mDNSDiscovery\r\n            state G4Discovery  \r\n            state ShureDiscovery\r\n            \r\n            [*] --\x3e mDNSDiscovery\r\n            [*] --\x3e G4Discovery\r\n            [*] --\x3e ShureDiscovery\r\n        }\r\n        \r\n        ParallelDiscovery --\x3e ProcessingResults : Device responses\r\n    }\r\n    \r\n    Running --\x3e Found : DeviceDiscovered event\r\n    Found --\x3e Running : Continue discovery\r\n    Running --\x3e Idle : StopDiscovery()\r\n    \r\n    note right of mDNSDiscovery\r\n        _ssc._udp.local (Sennheiser)\r\n        _ewd._http.local (Sennheiser)\r\n        Port 5353\r\n    end note\r\n    \r\n    note right of G4Discovery\r\n        UDP multicast 224.0.0.251:8133\r\n        Proprietary G4 protocol\r\n        ParseG4DeviceInfo()\r\n    end note\r\n    \r\n    note right of ShureDiscovery\r\n        SLP 239.255.254.253:8427\r\n        ParseShureSlpResponse()\r\n        TCP 2202\r\n    end note'}),"\n",(0,t.jsx)(n.h2,{id:"3-\xe9tats-de-monitoring-timer-30-secondes",children:"3. \xc9tats de monitoring (Timer 30 secondes)"}),"\n",(0,t.jsx)(n.h3,{id:"checksingledevicesync---machine-\xe0-\xe9tats-de-v\xe9rification",children:"CheckSingleDeviceSync - Machine \xe0 \xe9tats de v\xe9rification"}),"\n",(0,t.jsx)(n.mermaid,{value:'stateDiagram-v2\r\n    [*] --\x3e TimerTrigger\r\n    \r\n    state "Timer Callback" as TimerTrigger\r\n    state "Check Conditions" as CheckConditions\r\n    state "Create DeviceInfo" as CreateInfo\r\n    state "Handler Check" as HandlerCheck\r\n    state "Update States" as UpdateStates\r\n    state "Complete" as Complete\r\n    \r\n    TimerTrigger --\x3e CheckConditions : Every 30 seconds\r\n    \r\n    state CheckConditions {\r\n        [*] --\x3e ValidateDevice\r\n        ValidateDevice --\x3e CheckIsSynced : device != null\r\n        CheckIsSynced --\x3e GetHandler : device.IsSynced = true\r\n        GetHandler --\x3e [*] : handler found\r\n        \r\n        ValidateDevice --\x3e [*] : device = null (return)\r\n        CheckIsSynced --\x3e [*] : IsSynced = false (return)\r\n        GetHandler --\x3e [*] : no handler (return)\r\n    }\r\n    \r\n    CheckConditions --\x3e CreateInfo : Conditions OK\r\n    CreateInfo --\x3e HandlerCheck : DeviceDiscoveredEventArgs created\r\n    \r\n    state HandlerCheck {\r\n        [*] --\x3e CallIsDevicePendingSync\r\n        CallIsDevicePendingSync --\x3e ProcessResponse : await handler.IsDevicePendingSync()\r\n        ProcessResponse --\x3e [*] : (IsEqual, IsNotResponding)\r\n    }\r\n    \r\n    HandlerCheck --\x3e UpdateStates : Response received\r\n    \r\n    state UpdateStates {\r\n        [*] --\x3e CheckResponding\r\n        CheckResponding --\x3e SetOffline : IsNotResponding = true\r\n        CheckResponding --\x3e SetOnlineAndSync : IsNotResponding = false\r\n        \r\n        SetOffline --\x3e [*] : device.IsOnline = false\r\n        SetOnlineAndSync --\x3e [*] : device.IsOnline = true, device.PendingSync = !IsEqual\r\n    }\r\n    \r\n    UpdateStates --\x3e Complete\r\n    Complete --\x3e [*]'}),"\n",(0,t.jsx)(n.h2,{id:"4-\xe9tats-de-synchronisation---handlerisdevicependingsync",children:"4. \xc9tats de synchronisation - Handler.IsDevicePendingSync"}),"\n",(0,t.jsx)(n.h3,{id:"logique-de-v\xe9rification-sennheisershure",children:"Logique de v\xe9rification Sennheiser/Shure"}),"\n",(0,t.jsx)(n.mermaid,{value:'stateDiagram-v2\r\n    [*] --\x3e StartCheck\r\n    \r\n    state "Start Check" as StartCheck\r\n    state "Test Connectivity" as TestConnectivity\r\n    state "Compare Channels" as CompareChannels\r\n    state "Return Result" as ReturnResult\r\n    \r\n    StartCheck --\x3e TestConnectivity : handler.IsDevicePendingSync()\r\n    \r\n    state TestConnectivity {\r\n        [*] --\x3e SendSerialCommand\r\n        SendSerialCommand --\x3e CheckResponse : GetSerialCommand()\r\n        \r\n        state CheckResponse {\r\n            [*] --\x3e SennheiserCheck\r\n            [*] --\x3e ShureCheck\r\n            \r\n            SennheiserCheck --\x3e NotResponding : response = null or empty\r\n            SennheiserCheck --\x3e Responding : response OK\r\n            \r\n            ShureCheck --\x3e NotResponding : no "REP" in response\r\n            ShureCheck --\x3e Responding : contains "REP"\r\n        }\r\n        \r\n        NotResponding --\x3e [*] : return (false, true)\r\n        Responding --\x3e [*] : continue to channels\r\n    }\r\n    \r\n    TestConnectivity --\x3e CompareChannels : Device responding\r\n    TestConnectivity --\x3e ReturnResult : Device not responding\r\n    \r\n    state CompareChannels {\r\n        [*] --\x3e LoopChannels\r\n        \r\n        LoopChannels --\x3e GetChannelFreq : for each channel\r\n        GetChannelFreq --\x3e GetChannelName : frequency command\r\n        GetChannelName --\x3e CompareValues : name command\r\n        \r\n        CompareValues --\x3e NotEqual : frequency != expected OR name != expected\r\n        CompareValues --\x3e NextChannel : values match\r\n        \r\n        NotEqual --\x3e [*] : return (false, false)\r\n        NextChannel --\x3e LoopChannels : more channels\r\n        NextChannel --\x3e [*] : all channels OK, return (true, false)\r\n    }\r\n    \r\n    CompareChannels --\x3e ReturnResult : Comparison complete\r\n    ReturnResult --\x3e [*]\r\n    \r\n    note right of TestConnectivity\r\n        Sennheiser: UDP port 45\r\n        Shure: TCP port 2202\r\n        Commands via CommunicationService\r\n    end note\r\n    \r\n    note right of CompareChannels\r\n        Compare app values vs device:\r\n        channelInfo.Frequency vs device\r\n        channelInfo.Name vs device\r\n        Return IsEqual = false if different\r\n    end note'}),"\n",(0,t.jsx)(n.h2,{id:"5-\xe9tats-de-mapping---processus-mappingmodal",children:"5. \xc9tats de mapping - Processus MappingModal"}),"\n",(0,t.jsx)(n.h3,{id:"transformation-devicediscoveredeventargs-vers-rfdevice",children:"Transformation DeviceDiscoveredEventArgs vers RFDevice"}),"\n",(0,t.jsx)(n.mermaid,{value:'stateDiagram-v2\r\n    [*] --\x3e OnlineTabDisplay\r\n    \r\n    state "Online Tab Display" as OnlineTabDisplay\r\n    state "User Click Sync" as UserClickSync\r\n    state "Find Matching Devices" as FindMatching\r\n    state "Open Mapping Modal" as OpenModal\r\n    state "User Selection" as UserSelection\r\n    state "Execute Mapping" as ExecuteMapping\r\n    state "Save to Database" as SaveToDB\r\n    state "Update States" as UpdateStates\r\n    \r\n    OnlineTabDisplay --\x3e UserClickSync : Click "Sync!" button\r\n    UserClickSync --\x3e FindMatching : HandleSyncDevice()\r\n    \r\n    state FindMatching {\r\n        [*] --\x3e FilterDevices\r\n        FilterDevices --\x3e CheckMatches : Brand + Model + Frequency + !IsSynced\r\n        CheckMatches --\x3e ShowModal : matches found\r\n        CheckMatches --\x3e ShowError : no matches\r\n        ShowError --\x3e [*] : "No matching device found"\r\n        ShowModal --\x3e [*]\r\n    }\r\n    \r\n    FindMatching --\x3e OpenModal : Matching devices found\r\n    OpenModal --\x3e UserSelection : MappingModal displayed\r\n    UserSelection --\x3e ExecuteMapping : User selects device + sync direction\r\n    \r\n    state ExecuteMapping {\r\n        [*] --\x3e CastToRFDevice\r\n        CastToRFDevice --\x3e ChooseSyncDirection : CastDeviceDiscoveredToRFDevice()\r\n        \r\n        ChooseSyncDirection --\x3e SyncToDevice : "Sync to Device" selected\r\n        ChooseSyncDirection --\x3e SyncFromDevice : "Sync from Device" selected\r\n        \r\n        SyncToDevice --\x3e [*] : FirstSyncToDevice()\r\n        SyncFromDevice --\x3e [*] : FirstSyncFromDevice()\r\n    }\r\n    \r\n    ExecuteMapping --\x3e SaveToDB : Sync completed\r\n    \r\n    state SaveToDB {\r\n        [*] --\x3e CheckDeviceID\r\n        CheckDeviceID --\x3e AddItem : device.ID = 0\r\n        CheckDeviceID --\x3e UpdateItem : device.ID != 0\r\n        \r\n        AddItem --\x3e [*] : AddItemAsync<RFDevice>()\r\n        UpdateItem --\x3e [*] : UpdateItemAsync<RFDevice>()\r\n    }\r\n    \r\n    SaveToDB --\x3e UpdateStates : Database updated\r\n    \r\n    state UpdateStates {\r\n        [*] --\x3e SetMappedStates\r\n        SetMappedStates --\x3e [*] : IsSynced = true, IsOnline = true, PendingSync = false\r\n    }\r\n    \r\n    UpdateStates --\x3e [*]'}),"\n",(0,t.jsx)(n.h2,{id:"m\xe9triques-de-performance-des-\xe9tats",children:"M\xe9triques de performance des \xe9tats"}),"\n",(0,t.jsx)(n.h3,{id:"temps-de-transition-mesur\xe9s",children:"Temps de transition mesur\xe9s"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Transition"}),(0,t.jsx)(n.th,{children:"Impl\xe9mentation"}),(0,t.jsx)(n.th,{children:"Temps typique"}),(0,t.jsx)(n.th,{children:"Action en cas d'\xe9chec"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Discovery \u2192 Found"}),(0,t.jsx)(n.td,{children:"mDNS/SLP response"}),(0,t.jsx)(n.td,{children:"2-10s"}),(0,t.jsx)(n.td,{children:"Continue discovery"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"User Sync \u2192 Mapped"}),(0,t.jsx)(n.td,{children:"MappingModal workflow"}),(0,t.jsx)(n.td,{children:"1-3s"}),(0,t.jsx)(n.td,{children:"Show error message"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Timer Check"}),(0,t.jsx)(n.td,{children:"CheckSingleDeviceSync"}),(0,t.jsx)(n.td,{children:"30s interval"}),(0,t.jsx)(n.td,{children:"Log error, continue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Connectivity Test"}),(0,t.jsx)(n.td,{children:"TCP/UDP command"}),(0,t.jsx)(n.td,{children:"2-5s timeout"}),(0,t.jsx)(n.td,{children:"Set IsOnline = false"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Channel Comparison"}),(0,t.jsx)(n.td,{children:"Handler comparison"}),(0,t.jsx)(n.td,{children:"100-500ms"}),(0,t.jsx)(n.td,{children:"Set PendingSync = true"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"contraintes-d\xe9tats-r\xe9elles",children:"Contraintes d'\xe9tats r\xe9elles"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IsSynced"})," : D\xe9fini uniquement lors du mapping utilisateur"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IsOnline"})," : Mis \xe0 jour uniquement par le timer 30s via CheckSingleDeviceSync"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PendingSync"})," : Calcul\xe9 par comparaison app vs device physique"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timer requirement"})," : ",(0,t.jsx)(n.code,{children:"IsSynced = true"})," pour \xeatre v\xe9rifi\xe9"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handler requirement"})," : Brand match requis pour communication"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Ces diagrammes d'\xe9tats refl\xe8tent fid\xe8lement l'impl\xe9mentation r\xe9elle du syst\xe8me RF.Go bas\xe9e sur l'analyse du code source."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);